{% extends "midocs/page_base.html" %}{% load mi_tags testing_tags %}{% block content %}
{% index_entry "dynamical system" "discrete" %}
{% index_entry "discrete dynamical system" "introduction" %}
{% title "An introduction to discrete dynamical systems" %}
{% description "Overview of discrete dynamical systems, focusing on the simplest one-dimensional case, where the dynamics are given by iterating a function." %}

{% navigation_tag "video" "Video introduction" %}
<h4>Video introduction</h4>

{% boxedvideo "discrete_dynamical_system_introduction_1" %}

{% display_video_questions "discrete_dynamical_system_introduction_1" %}


{% boxedvideo "discrete_dynamical_system_introduction_2" %}

{% navigation_tag "overview" "Overview" %}
<h4>Overview</h4>


<p>{% intlink dynamical_system_idea %}Dynamical systems{%endintlink%} are about the evolution of some quantities over time.  This evolution can occur smoothly over time or in discrete time steps.  Here, we give an overview of dynamical systems where the state of the system evolves in discrete time steps, i.e., {% intlink discrete_dynamical_system_definition%}discrete dynamical systems{%endintlink%}.</p>

<p>When we model a system as a discrete dynamical system, we imagine that we take a snapshot of the system at a sequence of times.  For the sake of simplicity, we can imagine these snapshots are a fixed frequency, but they could occur at irregular intervals as well.  The snapshots could occur once a year, once every millisecond, or once every time a new government is elected.</p>

<p>When we take these snapshots, what are we recording?  As discused on the page giving the {% intlink dynamical_system_idea %}idea of dynamical systems{%endintlink%}, what we care about in dynamical systems is the evolution of our chosen {% intlink state_variable_definition%}state variables{%endintlink%} through the {% intlink state_space_definition%}state space{%endintlink%}.  By definition, the measurement of these state variables determine the future evolution of the system, so in our snapshots, we must record the values of these state variables.</p>

<p>The evolution of a discrete dynamical system, therefore, is captured by a sequence of snapshots of the state variables, where each snapshot is labeled by the time that it was taken.  To complete the description of the dynamical system, we need to specify a rule that determines, given an initial snapshot, what the resulting the sequence of future snapshots must be. </p>

{% navigation_tag "simplest" "Simplest case" %}
<h4>The simplest case</h4>

<p>In the simplest case of a discrete dynamical system, the state space consists of just one state variable, which we'll denote by $x$.  For this type of system, all the snapshots mentioned above are just records of the value of $x$ at different times.  In this simplest case, the rule for time evolution is also exceedingly simple.  The value of $x$ at each snapshot depends just on the value of the previous snapshot of $x$.  This value isn't influenced by the actual time of the snapshot, or any earlier values of $x$.  If I look at what $x$ is in any given snapshot, I have enough information (given the rule) to know exactly the value of $x$ in the next snapshot.</p>

<p>Since the times of the snapshots don't matter, let's label the sequence of times by integers, so that the snapshots occur at times $t=0,1,2,3, \ldots.$  We'll denote the value of $x$ in the snapshot at time $t=n$ by $x_n$, so the sequence of snapshots is $x_0,x_1,x_2,x_3, \ldots.$  The simple evolution rule for producing this sequence must involve a process that determines each snapshot $x_n$ by looking just at the previous snapshot $x_{n-1}$.</p>

<p>The evolution rule therefore requires a machine that takes in one snapshot as the input and produces the next snapshot.  In other words, the evolution rule must be based on a {% intlink function_definition%}function{%endintlink%}, which is well described as a {% intlink function_machine %}function machine{%endintlink%}, that takes the snapshot $x_n$ at time $t=n$ and produces the next snapshot $x_{n+1}$ at time $t=n+1$.</p>

<p>Let's denote the function that gives the next snapshot by $f$.  Then, the evolution rule can be written simply as
\begin{gather}
  x_{n+1} = f(x_{n}) \quad \text{for $x=0,1,2,3, \ldots.$}
  {% equation_tag "recursion" 1 %}
\end{gather}
Using the {% intlink function_machine %}function machine metaphor{%endintlink%}, our evolution rule looks like the following figure, where the snapshots are represented by spheres.</p>
{% image function_machine_single_iteration %}

<p>To get the dynamical system going, we have to specify the <em>initial conditions</em>, meaning the state variable $x_0$ at time $t=0$.  Given the initial snapshot $x_0$ and the rule $f$, we have now determined all the future snapshots.  The snapshot $x_1$ at time $t=1$ is the result of appling $f$ to the initial conditions,
\begin{gather*}
  x_1 = f(x_0).
\end{gather*}
The snapshot $x_2$ at time $t=2$ is the result of applying $f$ to the snapshot $x_1$ at time $t_1$, which is equivalent to applying $f$ to the initial condition, then sticking the result back into $f$ for a second pass through the function machine,
\begin{gather*}
  x_2 = f(x_1) = f(f(x_0)).
\end{gather*}
</p>

<p>We can continue this process:
\begin{align*}
  x_3 &= f(x_2) = f(f(x_1))=f(f(f(x_0)))\\
  x_4 &= f(x_3) = f(f(x_2))=f(f(f(x_1)))=f(f(f(f(x_0)))).
\end{align*}
It's a pretty simple process, but writing it out like this gets a bit messy.  That's why it easiest to just leave it in terms of the original rule of equation \eqref{recursion}.  Equation \eqref{recursion} captures all the steps of the process.  We can call it a <em>{% intlink recurrence_relation_definition%}recurrence relation{%endintlink%}</em> because it tells us to keep applying $f$ over and over again recursively, using the previous output as the next input.</p>

<p>The process of using the output of a function as the input of another function is called {% intlink composition_definition %}composing{%endintlink%} functions.  Function composition is {% intlink function_machine_composition %}well illustrated by function machines{%endintlink%}.  The following figure shows that if we start with the snapshot $x_n$ at time $t=n$ and apply $f$ twice, we get the result $x_{n+2}$ for two time steps later, at time $t=n+2$.  The whole process of evolving this discrete dynamical system could be visualized as a huge chain of these identical function machines hooked together.  Since we are composing the same function over and over again, the process is often called <em>function iteration</em>.</p>

{% image function_machine_two_iterations %}


<p>This simple case seems pretty straightforward. Since we have only one state variable, we have a one-dimensional {% intlink state_space_definition %}state space{%endintlink%}, which we can view as just a number line.  The state $x_n$ at time $t=n$ is just a point the number line.  At the next time step, the point just jumps to a new position $x_{n+1}$.</p>

{% image function_iteration_two_steps_number_line %}

<p>The following applet lets you explore this function iteration to obtain the sequence of snapshots $x_n$ for a discrete dynamical system.  You can specify the two ingredients, the function $f$ and the initial condition $x_0$, and then iterate the function to produce the resulting sequence of snapshots $x_1,x_2,x_3,\ldots$ or the {% intlink trajectory_dynamical_systems_definition%}trajectory{%endintlink%} of the initial point $x_0$.  In this applet, we've turned things around a bit, as we are plotting the state space for the snapshots $x_n$ as the vertical axis (which we've highlighted in blue to stress that's where all the action is taking place).  We've reserved the horizontal axis to represent time $t$.  As you iterate the function and the point jumps around the vertical state space, the temporal sequence of these jumps is illustrated with a plot of the points $(n,x_n)$ in the left panel and a list of these points in the right panel.</p>


{% boxedapplet "function_iteration" %}

<p>Although a discrete dynamical systems in one variable may seem simplistic, it turns out that these systems are surprisingly mathematically rich.  One-dimensional discrete dynamical systems can exhibit a large variety of dynamical behavior.  We can easily create systems that demonstrate the following behaviors.
<ul class="no_skip">
<li>Simple evolution to a fixed point: use the default function $f(x)=1+0.8x$ in the above applet.</li>
<li>Blow up: set $f(x)=2x$ to get the {% appletlink "bacteria_doubling" %}bacteria doubling system{%endappletlink%} discussed {% intlink dynamical_system_idea bacteria_doubling %}here{%endintlink%}.</li>
<li> {% intlink periodic_orbit_definition %}Periodic orbits{%endintlink%}: try $f(x)=1-0.8x^2$, or for a more complicated periodic orbit, try $f(x)=3.55x(1-x)$. </li>
<li>{% intlink chaos_definition%}Chaos{%endintlink%}: try $f(x)=4x(1-x)$ and change the initial conditions $x_0$. </li>
</ul>
 {% comment %}We can use one-dimensional discrete dynamical systems to model cool things.  Chaos, growth, death.  Use them to introduce the derivative.{%endcomment%}</p>

{% navigation_tag "extensions" "Extensions" %}
<h4>Extensions to the simplest case</h4>

{% navigation_tag "actualtime" "Extensions" "Actual time" %}
<h5>Dependence on actual time</h5>
  
<p>One possible way to extend the simplest case is to allow the evolution to depend on the time as well as the state variable.  For example, the dynamics might be influenced by something that depends on time day, such as the amount of light, by something that depends on the time of year, such as average temperature, or by some external force that varies with time.  In this case, the actual time of the snapshots might matter, so let's denote the time of the $n$th snapshot by $t_n$.  Then, the state variable at the next snapshot could depend not only on the previous value of the state variable $x_n$ but also on the time $t_n$ and equation \eqref{recursion} would be replaced by
\begin{gather*}
  x_{n+1} = f(x_n,t_n) \quad \text{for $x=0,1,2,3, \ldots,$}
\end{gather*}
where the function $f(x,t)$ depends on both state $x$ and time $t$.</p>

{% navigation_tag "moresnapshots" "Extensions" "More snapshots" %}
<h5>Dependence on more snapshots</h5>

<p>Another extension to the model is to allow the evolution to depend not only on the current state but also on the state of some previous snapshots.  For example, imagine that $x_n$ represented the number of individuals in a population of some species and that individuals couldn't reproduce until they were one time step old.  Then, the evolution of the population at time $t=n$ would depend not only on the current population size $x_n$ but also on the population size $x_{n-1}$ of the previous time step $t=n-1$, as $x_{n-1}$ represents those that were at least one time step old at time $t=n$ and could reproduce.  In this case, the recurrence relation \eqref{recursion} would be of the form
\begin{gather*}
  x_{n+1} = f(x_{n},x_{n-1}) \quad \text{for $x=1,2,3,4, \ldots,$}
\end{gather*}
where $f(x,y)$ is a function that depends on two inputs.</p>

{% navigation_tag "higher_dimensions" "Extensions" "Higher dimensions" %}
<h5>Higher dimensions</h5>
<p>In all the above cases, each snapshot was just a single number $x_n$.  A discrete dynamical system may be based on additional state variables that evolve together in time and whose dynamics are interrelated.  For example, in a predator-prey system, one variable may describe the population size of the predator and the other may describe the prey.  If the snapshot at time $t=n$ consists of two variables $x_n$ and $y_n$, the discrete dynamical system may have the form
\begin{align*}
  x_{n+1} &= f(x_{n},y_{n})\\
  y_{n+1} &= g(x_{n},y_{n})  \quad \text{for $x=0,1,2,3, \ldots,$}
\end{align*}
where the functions $f(x,y)$ and $g(x,y)$ determine how the two components evolve through the two-dimensional state space together.</p>
{% endblock %}

Cobwebbing on separate page
